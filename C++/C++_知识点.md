## C++ 个人知识欠缺清单
针对 《C++ Primer》 总结出自己对 C++ 知识技能欠缺的地方。

### 第一章：开始
* **程序块**： 零条或多条语句的序列，用花括号包围;  
* 附：
	* [Sale_item.h](./Sale_item.h)

### 第二章：变量和基本类型

* **何为对象？**：通常情况下，对象是指一块能存储数据并具有某种类型的内存空间。
* **关键字 extern **: 如果想声明一个变量而非定义它，就在变量名前添加关键字 `extern` ，而且不要显式地初始化变量;在函数体内部，如果试图初始化一个由 `extern` 关键字标记的变量，将引发错误 。 
```C++
extern int i ; // 声明 i 而非定义 i
int j ;       // 声明并定义 j 
extern double pi = 3.1416; //定义
```
* #### 引用
    * **引用** 为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成 `&d` 的形式来定义引用类型，其中 d 声明的变量名。
    ```
    int ival = 1024 ; 
    int &refVal = ival ; // refVal 指向 ival (是 ival 的另一个名字) 
    int &refVal2 ;  // 报错： 引用必须被初始化
    ```
    * 程序把引用和它的初始值**绑定**在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。  
    * **引用即别名，引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字** 因为引用的本身不是一个对象，所以不能定义引用的引用。
* #### 指针
    * 指针和引用相比有很多不同点。
        1. 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。
        2.  指针无须在定义时赋初值。
        3.  和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。
    * 如果指针指向了一个对象，则允许使用**解引用符**（操作符 * ）来访问该对象
    ```C++
    int *ip1 , *ip2 ; // ip1 和 ip2 都是指向 int 型对象的指针
    double dp , *dp2 ; // dp2 是指向 double 型对象的指针 , dp 是 double 型对象
    int ival = 42 ; 
    int *p = &ival ; //  p 存放变量 ival 的地址，或者说 p 是指向变量 ival 的指针
    *p = 0 ; // 由符号 * 得到指针 p 所指的对象，即可经由 p 为变量 ival 赋值

    double dval ; 
    double *pd = &dval ;  //正确 ：初始值是 double 型对象的地址
    double *pd2 = pd ;    //正确：初始值是指向 double 对象的指针

    int *pi = nullptr ; // 空指针
    pi = &ival // pi 的值被改变，现在 pi 指向了 ival 
    *pi = 0 ; //ival 的值被改变，指针 pi 并没有改变
    
    int i = 1024 , *p = &i , &r = i ; // i 是一个 int 型的数， p 是一个 int 型指针, r 是一个 int 型引用
    int *p1 , p2 ; // p1 是指向 int 的指针 , p2 是 int 
  	
    // 指向指针的引用
    int i= 42 ; 
    int *p ; // p 是一个 int 型指针
    int *&r = p ; // r 是一个对指针 p 的引用
    r = &i ; // r 引用了一个指针，因此给 r 赋值 &i 就是令 p 指向 i ;
    *r = 0 ; // 解引用 r 得到 i , 也就是 p 指向的对象 , 将 i 的值改为０；
    ```
    * 要理解 r 的类型到底是什么，最简单的办法是从右向左阅读 r 的定义。离变量名最近的符号（此例中是 &r 的符号 &） 对变量的类型有最直接的影响，因此 r 是一个引用。声明符的其余部分用以确定 r 引用的类型是什么，此例中的符号 * 说明 r 引用的是一个指针。最后，声明的基本数据类型部分指出 r 引用的是一个 int 指针.

* #### const 限定符
    * **const 限定符：** const 对象一旦创建后其值不能再改变，所以 const  对象必须初始化。
    ```C++
    const int bufSize = 512; // 输入缓冲区大小
    bufSize = 512 ; // 错误； 试图向 const 对象写值
    const int i = get_size() ; // 正确: 运行时初始化
    const int j = 42 ; // 正确：编译时初始化
    sonst int k ; //错误：k 是一个未经初始化的常量
    ```
    * 如果想在多个文件之间**共享 `const` 对象**，必须在变量的定义之前添加 `extern` 关键字。 `file_1.cc` 定义并初始化了 `bufSize` ，因为这条语句包含了初始值，所以它（显然）是一次定义，然而，因为 bufSize 是一个常量，必须用 extern 加以限定使其被其他文件使用。
    ```C++
    // file_1.cc 定义并初始化了一个常量，该常量能被其他文件访问
    extern const int bufSize = fcn() ; 
    // file_1.h 头文件
    extern const int bufSize; // 与 file_1.cc 中定义的 bufSize 是同一个
    ```
    * **const 的引用**
    ```C++
    const int ci = 1024 ; 
    const int &r1 = ci ; // 正确：引用及其对应的对象都是常量
    r1 = 42 ; // 错误： r1 是对常量的引用
    int &r2 = ci ; //错误： 试图让一个非常量引用指向一个常量对象
    ```
    * 允许一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式
    ```C++
    int i = 42 ; 
    const int &r1 = i ; //允许将 const int& 绑定到一个普通 int 对象上
    const int &r2 = 42 ; // 正确： r2 是一个常量引用
    const int &r3 = r1 * 2 ; // 正确：r3 是一个常量引用
    int &r4 = r1 * 2 ; // 错误： r4 是一个普通的非常量引用
    ```
    * **指针和 const** ， 和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他其他途径改变。*所谓指向常量的指针或引用，不过是指针或引用“自以为是”罢了，它们觉得自己指向了常量，所以自觉地不去改变所指向对象的值*
    ```C++
    const double pi = 3.14; // pi 是个常量，它的值不能改变
    double *ptr = &pi ; // 错误： ptr 是一个普通指针
    const double *cptr = &pi ; // 正确： cptr 可以指向一个双精度常量
    *cptr = 42; // 错误：不能给 *cptr 赋值
    
    double  dval = 3.14; // dval 是一个双精度浮点数，它的值可以改变
    cptr = &dval ; // 正确：但是不能通过 cptr 改变 dval 的值
    ```
    * **const 指针** , 指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量。**常量指针**必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再改变了。把 * 放在 const 关键字之前用以说明指针是一个常量，即不变的是指针本身的值而非指向的那个值。
    ```C++
    int errNumb = 0 ; 
    int *const curErr = &errNumb ; // curErr 将一直指向 errNumb 
    const double pi = 3.14159 ; 
    const double *const pip = &pi ; // pip 是一个指向常量对象的常量指针
    ```
* #### 类型别名
	* **类型别名** 是一个名字，它是某种类型的同义词
	```C++
    typedef double wages ; //wages 是 double 的同义词
    typedef wages base , *p ; // base 是 double 的同义词  ， P 是 double * 的同义词
    
    using SI = Sales_item ; // SI 是 Sales_item 的同义词
    ```
        * **重点提醒：**
        ```C++
        typedef char *pastring ; 
        const pastring cstr = 0 ; // cstr 是指向 char 的常量指针
        const char *cstr = 0; //指向常量 char 的指针
        const pstring *ps ; // ps 是一个指针，它的对象是指向 char 的常量指针
        ```
        遇到一条使用了类型别名的声明语句时，人们往往会错误地尝试把类型别名替换成它本来的样子，以理解语句的含义：
        ```
        const char *cstr = 0 ; // 是对　const pstring cstr 的错误理解
        ```  
        因为声明语句中用到 pstring 时，其基本数据类型是指针。 （上面的语句）用 char * 重写了声明语句后，数据类型就变成了 char , * 成为了声明符的一部分。这样改写的结果是，const char 成了基本数据类型。前后两种声明含义截然不同，前者声明了一个指向 char 的常量指针，改写后的形式则声明了一个指向 const char 的指针。
        
* #### 自定义数据结构
	* **#ifdef** 当且仅当变量已定义时为真，**#ifndef** 当且仅当变量未定义时为真，一旦检查结果为真，则执行后续操作直至遇到**#endif**指令为止。  
	* 
        
        