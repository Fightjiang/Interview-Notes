# 7. 重建二叉树

## 题目链接

[牛客网](https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=11157&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github)

## 题目描述

根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。



<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191102210342488.png" width="400"/> </div><br>

## 解题思路

前序遍历的第一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。然后分别对左右子树递归地求解。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/60c4a44c-7829-4242-b3a1-26c3b513aaf0.gif" width="430px"> </div><br>

```C++
class Solution {
public:
    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
        TreeNode *root = rebuild(pre , 0 , pre.size() - 1 , vin , 0 , vin.size() - 1) ; 
        return root ; 
    }
    
    TreeNode* rebuild(vector<int> pre , int pre_left , int pre_right ,vector<int> vin , int  vin_left , int vin_right) {
        if(pre_left > pre_right || vin_left > vin_right) {
            return NULL ; 
        }
        
        TreeNode *root = new TreeNode(pre[pre_left]) ; 
        for(int i = vin_left ; i <= vin_right ; ++i){
            if(pre[pre_left] == vin[i]) {
                root->left = rebuild(pre , pre_left + 1 , pre_left + i - vin_left , vin , vin_left , i) ; 
                root->right = rebuild(pre , pre_left + i - vin_left + 1 , pre_right , vin , i + 1 , vin_right ) ; 
            }
        }
        return root ; 
        
    }
};
```