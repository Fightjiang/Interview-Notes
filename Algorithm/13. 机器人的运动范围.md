# 13. 机器人的运动范围

[NowCoder](https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&tqId=11219&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github)

## 题目描述

地上有一个 m 行和 n 列的方格。一个机器人从坐标 (0, 0) 的格子开始移动，每一次只能向左右上下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 k 的格子。

例如，当 k 为 18 时，机器人能够进入方格 (35,37)，因为 3+5+3+7=18。但是，它不能进入方格 (35,38)，因为 3+5+3+8=19。请问该机器人能够达到多少个格子？

## 解题思路

使用深度优先搜索（Depth First Search，DFS）方法进行求解。回溯是深度优先搜索的一种特例，它在一次搜索过程中需要设置一些本次搜索过程的局部状态，并在本次搜索结束之后清除状态。而普通的深度优先搜索并不需要使用这些局部状态，虽然还是有可能设置一些全局状态。

```C++
class Solution {
public:
   bool judge(int threshold , int x , int y) {
        int sum = 0 ; 
        while(x) {
            sum += x % 10 ; 
            x /= 10 ; 
        }
        while(y) {
            sum += y % 10 ; 
            y /= 10 ; 
        }
        return sum > threshold ; 
    }
    int dfs(int threshold , int rows , int cols , int x, int y , vector<vector<bool>> &visit){
        if(judge(threshold , x , y)) {

            return 0 ; 
        }

        int ans = 1 ;
        int dir[4][2] = {{0,1} , {0,-1} , {1,0} , {-1,0}} ; 
        for(int i = 0 ; i < 4 ; ++i) {
            int xx = x + dir[i][0] ; 
            int yy = y + dir[i][1] ;
            if(xx >= 0 && xx < rows && yy >= 0 && yy < cols && visit[xx][yy] == false) {
               // cout<<xx<<" "<<yy<<endl;
                visit[xx][yy] = true ; 
                ans += dfs(threshold , rows , cols , xx , yy , visit); 
              //  visit[xx][yy] = false ;
            }
        }

        return ans ; 
    }

    int movingCount(int threshold, int rows, int cols)
    {
        vector<vector<bool>> visit(rows , vector<bool>(cols , false )) ; 
        visit[0][0] = true ; 
        return dfs(threshold , rows , cols , 0 , 0 ,  visit) ; 
    }
};
```



