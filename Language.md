## 指针

### 1. 常量指针和指针常量

> 常量指针： const char *str = "abcedf" ; 

因为 `const` 修饰的是 `char`，所以就是说： `str` 所指向的内存地址所对应的值，也就是 `*str` 是 `const` ，因此不可修改。但指针所指向的内存地址，也就是 `str`所指向的内存地址是可以修改的，因为其并不是const类型 。

```C++
    const char *str1 = "123456" ; 
    // char *str1 ; C++ 默认编译为 const char *str1 ; ISO C++ forbids converting a string constant to ‘char*’
    str1 = "abcdef" ;  // 成功，字符串常量的本质表现是它的第一个字符对应的地址 , 修改 str1 指向的内存地址成功。
    *str1 = 'a' ; //错误，*str1 是 const 不可以修改
```
> 指针常量：char* const str = "abcedf" 

因为 `const` 修饰的是指针 `str` ，也就是说：指针所指向的内存地址是 `const` ，不可修改。但 `str` 所指向内存地址所对应的值是可以修改的，因为其并不是 `const` 类型。

```C++
char str[10] = "abcdef" ; // str 就是指针常量 char *const , str 所指向的内存地址是不可以修改的。

void testconst(char * const str) {
    str = "123456" ; // 错误，
    *str = '1' ; // 正确
}

```

**总结：**

> （指针）和 const（常量） 谁在前先读谁 ；*象征着地址，const象征着内容；谁在前面谁就不允许改变。

```C++
    int a =3;
    int b = 1;
    int c = 2;
    int const *p1 = &b; // const 在前，定义为常量指针
    int *const p2 = &c; // * 在前，定义为指针常量 
    p1 = &a ;  //常量指针，正确，指针指向的内存地址可以改变
    *p1 = 6 ;  //常量指针，错误，指针指向的内存地址所对应的值不可以改变
    p2 = &a ;  //指针常量，错误，指针指向的内存地址不可以改变
    *p2 = 6 ;  //指针常量，正确，指针指向的内存地址所对应的值可以改变

    const int d = 4 ; // 定义常量
    int *ptr3 = &d ; //错误，不能把常量的地址赋给指针变量
    
```

### 2. 指针数组和数组指针


* 指针数组：指针数组可以说成是“指针的数组”，首先这个变量是一个数组，其次，”指针”修饰这个数组，意思是说这个数组的所有元素都是指针类型，在32位系统中，指针占四个字节。
```C++
char *arr[4] = {"hello", "world", "shannxi", "xian"}; // “[]”的优先级比“*”要高
//arr就是我定义的一个指针数组，它有四个元素，每个元素是一个char *类型的指针，这些指针存放着其对应字符串的首地址。
```

* 数组指针：数组指针可以说成是”数组的指针”，首先这个变量是一个指针，其次，”数组”修饰这个指针，意思是说这个指针存放着一个数组的首地址，或者说这个指针指向一个数组的首地址。
```C++
char (*pa)[4]; //数组指针
char a[4]; //字符数组

a是一个长度为4的字符数组，a是这个数组的首元素首地址。既然a是地址，pa是指向数组的指针，那么能将a赋值给pa吗？答案是不行的！因为a是数组首元素首地址，pa存放的却是数组首地址，a是 char [4]类型，a+1，a的值会实实在在的加1，而pa是 char (*)[4]类型的，pa+1，pa则会加4，虽然数组的首地址和首元素首地址的值相同，但是两者操作不同，所以类型不匹配不能直接赋值，但是可以这样：pa = &a，pa相当与二维数组的行指针，现在它指向a[4]的地址。


int a[3][4];
int (*pa)[4]; //该语句是定义一个数组指针，指向含4个元素的一维数组。
 pa = a;        //将该二维数组的首地址赋给p，也就是a[0]或&a[0][0]
 pa++;       //该语句执行过后，也就是p=p+1;p跨过行a[0][]指向了行a[1][]

所以数组指针也称指向一维数组的指针，亦称行指针。

```

## 面向对象

* 如何理解面向对象编程：
    1. 封装：之前的项目有调用过阿里云的短信接口用做验证码使用，我们把短信发送的这个 API 调用流程封装成一个类，在发送短信的时候只需要声明一个对象就能发送短信，就这个操作让我很体会封装的作用；安全性。
    
    2. 继承：继承之前发送短信的类，写发送彩信的代码，大量的减少了代码冗余。
    
    3. 多态：是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口；C++ 通过虚函数机制，通过基类指针，就能很方便的调用是子类接口和还是父类接口。

* 什么是多态
    1. 相同的消息给予不同的对象会引发不同的动作。具体的说，它主要表现在函数调用时，实现一种接口，多种方法。多态性时面向对象程序设计的另一个重要特征，C++ 支持两种多态性，编译时静态多态和运行时动态多态

    2. 静态多态：也称为编译期间的多态，编译器在编译期间完成的，编译器根据函数实参的类型(可能会进行隐式类型转换)，可推断出要调用那个函数，如果有对应的函数就调用该函数，否则出现编译错误。 静态多态有两种实现方式： 1. `函数重载：包括普通函数的重载和成员函数的重载` 2.`函数模板的使用`
    
    3. 动态多态（动态绑定）：即运行时的多态，在程序执行期间(非编译期)判断所引用对象的实际类型，根据其实际类型调用相应的方法。 运行时多态性指的是属于某个基类的不同派生类对象，在形式上调用的是继承自己的基类的同一成员函数，实际上调用的却是各自派生的同名函数，这是一种动态多态性，因为函数名，函数参数和返回类型都相同的情况下，编译阶段不能确定要调用的函数，只能在程序运行时确定这种多态性，这种多态性通过虚函数机制实现。在父类中声明为加了 virtual 关键字的函数，在子类重写时不需要加 virtual ，不过建议加上，方便识别。`虑到程序中的每个函数都在内存中有着唯一的地址，我们可以将具体函数的地址作为成员变量，存放在对象之中，这样就可以在运行时，通过访问这个成员变量，获取到实际类型虚函数的地址。`

* 什么是虚函数
    > `C++` 多态 `(polymorphism) `是通过虚函数来实现的，虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖(override)，或者称为重写。

    > 构造函数不可以是虚函数，虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了。

* RTTI : (Run-Time Type Identification ) 
    > 提供运行时类型信息 , 将类型信息的地址加入到虚表之中。为了避免虚函数表长度对其位置的影响，g++将它放在虚函数表的前
    > 


* 静态函数和虚函数
    > 静态函数在编译时已经确定了运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销

* This 指针
    
    1. 当对一个对象调用成员函数时，编译程序先将对象的地址赋给` this `指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用` this `指针。

    2. `this` 指针被隐含地声明为: `ClassName const this`，这意味着不能给 `this` 指针赋值；在 `ClassName` 类的 `const` 成员函数中，`this` 指针的类型为：`const ClassName const`，这说明 `this `指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；
    
    3. `this` 并不是一个常规变量，而是个右值，所以不能取得 `this` 的地址（不能 &this）。

    4. 在以下场景中，经常需要显式引用 this 指针：
        * 为实现对象的链式引用；
        * 为避免对同一对象进行赋值操作；
        * 在实现一些数据结构时，如 list。

* [重载、覆盖(重写)、隐藏](https://blog.csdn.net/qq_26437925/article/details/54933326)



## C++ 基础

### [1.new 与 malloc 的 区别，delete 和 free 的区别](https://blog.csdn.net/Hackbuteer1/article/details/6789164)
1. `malloc` 与 `free` 是 `C++/C` 语言的标准库函数，`new/delete` 是 `C++` 的运算符。它们都可用于申请动态内存和释放内存。
2. 对于非内部数据类型的对象而言，光用 `malloc/free` 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于 `malloc/free` 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于`malloc/free`。 而 `new/delete` 会自动调用构造和析构函数
3. 为什么`C++`还保留`malloc/free`呢？因为`C++`程序经常要调用`C`函数，而`C`程序只能用`malloc/free`管理动态内存。
4. `new`可以认为是`malloc`加构造函数的执行。`new`出来的指针是直接带类型信息的。而`malloc`返回的都是`void`指针。
5. 如果用`free`释放“`new`创建的动态对象”，那么该对象因无法执行析构函数而可能导致程序出错。如果用`delete`释放“`malloc`申请的动态内存”，理论上讲程序不会出错，但是该程序的可读性很差。所以`new/delete`、`malloc/free`必须配对使用。
6. 内存分配失败时的返回值: `new`内存分配失败时，会抛出`bac_alloc`异常，它不会返回`NULL`；`malloc`分配内存失败时返回`NULL`。


### 2. static 作用是什么？在C和C++中有何区别？
1. `static`可以修饰局部变量（静态局部变量）、全局变量（静态全局变量）和函数，被修饰的变量存储位置在`静态区`。 对于`静态局部变量`，相对于一般局部变量其生命周期长，直到程序运行结束而非函数调用结束，且只在第一次被调用时定义，未初始化时，`static` 变量默认值为 0 ; 对于`静态全局变量`，相对于全局变量其可见范围被缩小，只能在本文件中可见；对于`修饰函数`时作用和`修饰全局变量`相同，都是为了限定访问域，普通函数的定义和声明默认情况下是`extern`的，其他文件中可以定义相同名字的函数，不会发生冲突。
2. `C++`的`static`除了上述两种用途，还可以`修饰类成员`（静态成员变量和静态成员函数），静态成员变量和静态成员函数不属于任何一个对象，是所有类实例所共有。
3. `static`的数据记忆性可以满足函数在不同调用期的通信，也可以满足同一个类的多个实例间的通信。

### 3. 指针和引用区别？
```C++
int a = 1 ; 
int *p = &a ; 
int &b = a ; 
```
1. 引用只是别名，不分配具体存储空间 ；指针是具体变量，需要占用存储空间。
2. 引用在声明时必须初始化为另一变量；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。
3. 引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。
4. 不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。

### 5. Lambda 表达式

1. 定义简单的`lambda`表达式
    ```C++
    auto basicLambda = [] { cout << "Hello, world!" << endl; };
    // 调用
    basicLambda();   // 输出：Hello, world!
    ```
2. 添加参数
    ```C++
    // 自动推断返回类型
    auto multiply = [](int a, int b) { return a * b; };
    int product = multiply(2, 5);  // 输出：10
    ```
3. 前面的 `[]` 就是用来定义捕捉模式以及变量，我们又将其称为lambda捕捉块。看下面的例子：
    ```C++
    int x = 10;
    
    auto add_x = [x](int a) { return a + x; };  // 复制捕捉x
    auto multiply_x = [&x](int a) { return a * x; };  // 引用捕捉x
    
    cout << add_x(10) << " " << multiply_x(10) << endl;
    // 输出：20 100
    return 0;
    ```


### 7. inline 内联函数

* **特征**： 
    1. 相当于把内联函数里面的内容写在调用内联函数处，不用执行进入函数的步骤，直接执行函数体；
    2. 相当于宏，却比宏多了类型检查，真正具有函数特性 ； 
    3. 编译器一般不内联包含循环、递归、`switch` 等复杂操作的内联函数；
    4. 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。
* **编译器对 inline 函数的处理步骤**
    1. 将 `inline` 函数体复制到 `inline` 函数调用点处；
    2. 为所用 `inline` 函数中的局部变量分配内存空间；
    3. 将 `inline` 函数的的输入参数和返回值映射到调用方法的局部变量空间中；
    4. 如果 `inline` 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。
* **优缺点**
    * **优点**
        1. 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。
        2. 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。
        3. 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。
        4. 内联函数在运行时可调试，而宏定义不可以。
    * **缺点**
        1. 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。
        2. `inline` 函数无法随着函数库升级而升级。`inline`函数的改变需要重新编译，不像 `non-inline` 可以直接链接。
        3. 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。

* **虚函数（virtual）可以是内联函数（inline）吗？**
    * 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。
    * 内联是在编译期间建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。
    * `inline virtual` 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 `Base::who()`），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。
    * 虚函数内联使用:
    ```C++
    #include <iostream>  
    using namespace std;
    class Base
    {
    public:
        inline virtual void who()
        {
            cout << "I am Base\n";
        }
        virtual ~Base() {}
    };
    class Derived : public Base
    {
    public:
        inline void who()  // 不写inline时隐式内联
        {
            cout << "I am Derived\n";
        }
    };

    int main()
    {
        // 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 
        Base b;
        b.who();

        // 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  
        Base *ptr = new Derived();
        ptr->who();

        // 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。
        delete ptr;
        ptr = nullptr;

        system("pause");
        return 0;
    } 
    ```

### 8. 左值，右值
1. 在C++11中所有的值必属于左值、右值两者之一，右值又可以细分为纯右值、将亡值。**在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）**。举个例子，int a = b+c, a 就是左值，其有变量名为a，通过&a可以获取该变量的地址；表达式b+c、函数int func()的返回值是右值，在其被赋值给某一变量前，我们不能通过变量名找到它，＆(b+c)这样的操作则不会通过编译。
2. std::move函数可以以非常简单的方式将左值引用转换为右值引用。
3. std::move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝所以可以提高利用效率,改善性能.。

### 9. 4 个强制类型转换运算符

* **static_cast**
    1. 通常用于转换数值数据类型（如 `float -> int`）
    2. 不执行运行时类型检查
* **dynamic_cast**
    1. 用于多态类型的转换 ； 执行行运行时类型检查 ； 只适用于指针或引用 ； 
    2. 它能安全地将指向基类的指针转型为指向子类的指针或引用，并获知转型动作成功是否。转型失败会返回`null`（转型对象为指针时）或抛出异常`bad_cast`（转型对象为引用时）。
* **const_cast**
    1. 用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ）
* **reinterpret_cast**
    1. 能够完成任意指针类型向任意指针类型的转换，即使它们毫无关联。尽量少用。

### 10. C++和C相比最大的特点

    1. 面向对象：封装，继承，多态。
    2. 引入引用代替指针。
    3. const /inline/template替代宏常量。
    4. namespace解决重名的问题。
    5. STL提供高效的数据结构和算法



## 其他

### 1. C++ 内存四区

1. 栈区 ：由编译器自动分配释放，存放函数的参数值，局部变量等值。大小一般为` 1 M`
2. 堆区 ：一般由程序员分配释放， 若程序员不释放，程序结束时可能由`OS`回收。大小为虚拟内存大小
    * 堆：是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用`malloc()`时就会从中分配，稍后调用`free()`可把内存交还。
    * 自由存储区：自由存储是`C++`中通过`new`和`delete`动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。
3. 数据段
    * 只读数据段：一般是`const`修饰的变量以及程序中使用的文字常量一般会存放在只读数据段中。
    * 全局 & 静态区：全局变量和静态变量被分配到同一块内存中
        * 全局初始化区：存储程序中已初始化的全局变量和静态变量
        * 未初始化段(BSS段)：存储未初始化的全局变量和静态变量（局部+全局）
4. 代码段
    * 包括只读存储区和文本区，其中`只读存储区存储字符串常量`，就是常量区，文本区存储程序的机器代码。

### 2. 内存对齐的原则
1. 结构体的总大小，必须要是其内部最大成员的整数倍，不足的要补齐 。
2. 结构体或联合的数据成员，第一个数据成员是要放在offset == 0的地方，如果遇上子成员，要根据子成员的类型存放在对应的整数倍的地址上 。 
3. 如果结构体作为成员，则要找到这个结构体中的最大元素，然后从这个最大成员的整数倍地址开始存储。

