## 1. 常见的进程间通信的方式
1. 管道：
    * 匿名管道（Pipe）是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系 , 也有兄弟关系，如我们经常使用的命令 `|` 就是可以看成兄弟进程。
    * Pipe 创建匿名管道，通常采用父子进程进行通信；父进程创建管道，得到两个⽂件描述符指向管道的两端；父进程fork出子进程，⼦进程也有两个⽂件描述符指向同⼀管道 ； 
    * fork() 函数返回 0 是子进程，1 是父进程
    * pipefd[0] 读，pipefd[1] 写
    * 命名管道（FIFO）与匿名管道最大不同就在于它可以用于不具备亲缘关系的进程进行通信 。FIFO不同于管道之处在于它提供一个路径名与之关联，以FIFO的文件形式存储于文件系统中。命名管道是一个设备文件，因此，即使进程与创建FIFO的进程不存在亲缘关系，只要可以访问该路径，就能够通过FIFO相互通信。
2. 信号量：
    * 信号量是一个特殊的变量，程序对其访问都是原子操作，且只允许对它进行等待（即P(信号变量))和发送（即V(信号变量))信息操作。我们通常通过信号来解决多个进程对同一资源的访问竞争的问题，使在任一时刻只能有一个执行线程访问代码的临界区域，也可以说它是协调进程间的对同一资源的访问权，也就是用于同步进程的。
3. 消息队列：
    * 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
4. 共享内存：
    * 共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC（InterProcess Communication 进程间通信） 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
5. 信号：
    * 信号是UNIX和Linux系统响应某些条件而产生的一个事件，信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生，接收到该信号的进程会相应地采取一些行动。
    * 常见的一些信号:
        ```C++
        1. SIGINT : 一般由从终端敲入的 Ctrl + C 组合键或预先设置好的终端字符产生
        2. SIGKILL : 因为这个信号不能被捕获或忽略，所以一般在 shell 中用它来强制终止异常进程
        3. SIGSTOP : 停止执行，此信号不能被捕获或忽略
        4. SIGTERM : 作为一个请求被发送，要求进程结束运行。UNIX 在关机时用这个信号要求系统服务停止运行。它是 kill 命令默认发送的信号。
        5. SIGALRM : 时钟定时信号, 计算的是实际的时间或时钟时间.alarm函数使用该信号.
        ```
6. 套接字（socket）：套接字与其他通信机制不同的是，它可用于不同机器之间的进程通信。
    1. client 
        ```C++
        1. socket()
        2. connect 
        ```

## 2. 硬连接和软连接的理解

硬链接是指针，所有的硬链接都是指向同一个磁盘块。 删除一个指针不会真正删除文件，只有把所有的指针都删除才会真正删除文件。 软连接是另外一种类型的文件，保存的是它指向文件的全路径， 访问时会替换成绝对路径

* 硬连接(ln test1 test2)：多个文件名指向同一索引节点（inode），允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。
* 软连接(ln -s test1 test3)：保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块，访问时替换自身路径。

## 3. 大小端模式及如何检测

* 大端模式：是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址端。
* 小端模式，是指数据的高字节保存在内存的高地址中，低位字节保存在在内存的低地址端。

    1. 直接读取存放在内存中的十六进制数值，取低位进行值判断
        ```C++
        int a = 0x12345678 ; 
        char *c = (char *)&a ; 

        if(*c == 0x12) {
            cout<<"大端模式"<<endl ; 
        }else {
            cout<<"小端模式"<<endl ; 
        }
        ```
    2. `Union`共同体所有数据成员是共享一段内存的，后写入的成员数据将覆盖之前的成员数据，成员数据都有相同的首地址。`Union`的大小为最大数据成员的大小。`Union`的成员数据共用内存，并且首地址都是低地址首字节。`int i= 1`时：大端存储1放在最高位，小端存储1放在最低位。当读取`char ch`时，是最低地址首字节，大小端会显示不同的值。
    ```C++
        //return 1 : little-endian
        //       0 : big-endian
        int checkCPUendian()
        {
            union {
                unsigned int a;
                unsigned char b; 
            } c;

            c.a = 1;
            return (c.b == 1); 
        }
    ```

* 大小端模式相互转换
    ```C++
    // 使用移位运算
    uint32_t reversebytes_uint32t(uint32_t value){
        return (value & 0x000000FFU) << 24 | (value & 0x0000FF00U) << 8 | 
            (value & 0x00FF0000U) >> 8 | (value & 0xFF000000U) >> 24; 
    }
    上述代码中，将低8位（0~8位）左移24位，变成了高8位（24~32位），8~16位左移8位变成了
    （16~24位）。将原高8位和高16位右移，变成了新的低8位和低16位。
    ```
## 4. [linux中fork（）函数详解](https://blog.csdn.net/jason314/article/details/5640969)

* fork() 之后，子进程会拷贝父进程的数据空间、堆和栈空间（实际上是采用写时复制技术），二者共享代码段。 所以在子进程中修改全局变量（局部变量，分配在堆上的内存同样也是）后，父进程的相同的全局变量不会改变。相当于克隆了一个自己。
* 共享fd，以及fd对应的文件表项，如：管道通信

* 1)对于父进程，fork函数返回新建子进程的pid；2)对于子进程，fork函数返回 0；3)如果出错， fork 函数返回 -1。

## 5. 同步、异步、阻塞与非阻塞

1. 当一个同步调用发出后，调用者要一直等待返回消息（结果）通知后，才能进行后续的执行；当一个异步过程调用发出后，调用者不能立刻得到返回消息（结果），实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。

2. 阻塞调用是指调用结果返回之前，当前线程会被挂起，一直处于等待消息通知，不能够执行其他业务。非阻塞，则可以去执行其他业务。

3. 同步和异步关注的是消息如何通知的机制，而阻塞与非阻塞关注的是等待消息通知时的状态。也就是说，同步的情况下，是由处理消息者自己去等待消息是否被触发，而异步的情况下是由触发机制来通知处理消息者。

## 6. 用户态和内核态的区别

* 用户态：运行用户程序
* 内核态： 运行操作系统程序，操作硬件，并提供上层应用程序运行的环境。
* 系统调用：为了使上层应用能够访问到这些资源，内核为上层应用提供访问的接口。用户程序通常调用库函数，由库函数再调用系统调用，因此有的库函数会使用户程序进入内核态（只要库函数中某处调用了系统调用），有的则不会。比如前例中fork()实际上就是执行了一个创建新进程的系统调用。

## 7.进程和线程
* **进程切换的开销**
    1. 切换页表全局目录
    2. 切换内核态堆栈
    3. 切换硬件上下文：寄存器当中的数据
    4. 刷新TLB
    5. 间接开销指的是由于切换到一个新进程后，各种缓存对于新的进程而言未命中的概率非常大。进程如果跨`CPU`调度，那么之前的`TLB、L1、L2、L3`缓存因为运行的进程已经变了，缓存所带来的空间局部性和时间局部性的优势失效，当前缓存起来的代码、数据失效。这将导致新进程需要重新从内存当中获取数据和代码，并将其缓存起来。从而导致穿透到内存的IO会变多，由于CPU和内存读取速度的差异很大，这部分带来的开销也非常大。

* **线程切换的开销**
    1. 在线程切换期间，虚拟内存空间保持不变。
    2. 进程切换期间，TLB会被刷新，从而使内存访问在一段时间内变得更加昂贵。

* **进程线程的本质区别**
    1. 进程更安全，一个进程完全不会影响另外的进程。
    2. 进程间通信比线程间通信的性能差很多。
    3. 线程切换开销更低。

* **线程共享哪些进程的资源？**
    1. 进程代码段 ；
    2. 进程的公有数据；
    3. 进程打开的`文件描述符`；
    4. 进程的当前目录；
    5. 进程用户`ID`与进程组`ID`。
    6. 信号的处理器；

* **协程和线程的区别？**
    1. 线程是操作系统调度的最小单元，线程是由操作系统调度。但是操作系统对于协程是无感知的，协程的调度 是在用户态而非由操作系统在内核态调度。
    2. 相比创建一个线程而言，创建一个协程的开销非常小。
    3. 协程之间的切换开销相比线程间切换开销低很多。
    4. 协程比线程支持更大的并发量。
    5. 协程不支持抢占，因为操作系统有时间片概念，所以线程是支持优先级和抢占的，但是协程是在用户态实现，协程是非抢占式调度。在任务调度上，协程是弱于线程的。

